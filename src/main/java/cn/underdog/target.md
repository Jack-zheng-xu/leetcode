学习目标：习BFS,和双向BFS(DFS适合查找是否存在一条路径，BFS适合查找最短路径迪杰斯特拉算法)
不会的知识点：
图：迪杰斯特拉，Prim,Floyd
字典树，树状数组，
遇到子数组或者子字符串要想到滑动窗口
打卡
未开始：
数组：1401
树：1028，971，894，1530，1145，889，1372，979
字符串：，816

不熟：
1041 1763 1829 1442 1419 1834 768 1510 787 983 1262 1774 923 1191 948 918，698 473 139 2266 1801,1497,1765,1895,
链表：1171
二分图：886
字符串：1079
单调栈：1673
数学：2048,1015
脑筋急转弯：2017
图：1042,1519
动态规划：1567
滑动窗口:1839，1477
差分数组：1871,2406
贪心：1326,955
KMP :1392
Hash表：1546
二维dp:1594,1458
最短路径1345
记忆化搜索：1458
dijistra:1514



不会：
265，1824,1424,1129,1824，1954
位运算：1072,1016,1238，1073,1284,861,995
数学：1953，1359,1363
字符串：966，1156
大模拟：1914，764，1391，1139，1292
拓扑排序：1722
单调栈：1526
广度优先：773
后缀数组：1754
树：1080
不会：1124


数学：
求余数问题，在 C++ 和 Java 语言中，将负数 x 对一个正数 k 进行取模操作，得到的结果小于等于 0（即在 [-k+1, 0][−k+1,0] 的范围内）。
我们可以通过：xk = (x % k + k) % k得到在 [0, k-1] 的范围内的余数。
char ==> int num.charAt(0) - '0'
int ==>char 9+ '0'
大数
BigInteger 
 



800 2020.8.24

